## 1、写在前面
用汇编语言作为自己程序设计的主流语言是不现实的，当代码量达到一定程度后，代码的维护会变困难，甚至不可能实现。

但我们仍要学习汇编语言，但学习汇编的目的不是用它去进行实实在在的程序设计，而是充分获得底层的编程体验和深刻理解机器运行程序的机理。

另外，对于一个人来说，不能没有常识，尽管常识不能直接挣钱吃饭，但它影响谈吐，影响你的判断力和决断力，决定着你接受新事物和新知识的程度。相应的，汇编语言就是就是计算机语言里面的常识和基础。

倘若你学过C语言，并且精通它，再去学习汇编，你会对C语言有着新的理解，这种理解更加有助于你进行程序设计。大家都说，C++相当的复杂，但也有人说，C++的复杂都是一些骗人的表象，C++被编译完成后，它和C几乎是一样的东西。在C语言中，指针那一部分讲到了地址这一概念，但在汇编中，关于地址的应用无处不在，简单的几行汇编代码就不得不用到地址。但有时候，我们无法明显的区分什么是地址，什么是数据。实际情况是这样的，地址有时候可以是数据，数据有时候也可以是地址。

其实，在C/C++中，每一个变量名，每一个函数名都将被C或C++的编译器编译成地址。但是，有时候地址和数据是不被加以区分的。

我们可以不太恰当的把CPU里面的各种寄存器（被CPU频繁使用的那些寄存器）当成CPU的“演草纸”，当然了，我们在演草纸上计算微积分的时候可能会乱涂乱画，但CPU不会。而且CPU对它的“演草纸”的“擦”和“写”的速度相当的快速。

不同的CPU会有不同的汇编指令，只需要理解一种常用的、结构简单的CPU的汇编指令，再研究别的CPU的时候，就会比较顺利了。

考虑一下盖一栋房子时会经历的步骤：沙土、水泥、钢材、木材、铝材......——>砖块、瓦片、水泥板......——>一面墙、一扇窗......——>一栋房子；再考虑一下程序设计语言的大致发展过程：机器语言——>汇编语言——>高级程序设计语言（结构化程序设计语言）——>高级程序设计语言（面向对象的程序设计语言）——>可以直接使用的各种框架（比如Python中的web框架——Django框架）或模块（比如Python中可以和MATLAB相媲美的科学计算库——numpy和matplotlib）。其实倒着看程序设计语言的发展过程，感觉和反编译较为相似。

经过以上比较，盖房子的过程和程序设计语言的发展过程有诸多相似之处。如果把各种连接在一起（比如通过互联网连接在一起）计算设备比喻成程序的生存环境（我们不妨称其为“计算环境”），那么程序设计便是在这个环境中搭建房屋，创造生灵，这也恰恰体现了面向对象程序设计中的一句名言——万物皆对象。再考虑一下计算机病毒，就会感觉这种比喻更加的恰当了。computer virus就是这个计算环境中的有害“生灵”，这些程序只会破坏“计算环境”，传染速度也非常的快，破坏力非常强，比如熊猫烧香的破坏力可以和现实世界中的埃博拉相媲美。

说到这就扯得有点远了，接下来言归正传。
汇编语言就像高大建筑物中的沙土、水泥、钢材......在盖房子的时候，为了提高效率，我们要从砖块起步，甚至一面墙起步。但砖和墙到底由什么组成，是否足够结实，我们就需要了解其基本组成。是程序设计语言都要基于一定的CPU，有CPU就会有指令集。所以，学习汇编很有必要！

## 2、一切都是编码

###### 2.1 人类用编码表示世界
汉子是一种象形文字，也就是说，汉子是用图形进行编码的。比如说，拼音，就是将一个个的音节拼接起来，所以拼音是对我们人类发出声波的一种编码方式。再比如，经纬度是对地球上任意一个位置的编码，再比如，人类对对星系的编码也是用图形。最典型的便是生物的遗传物质（比如说DNA），也是一种编码方式。遗传物质将决定一个人的性别、身高、是否双眼皮、智力、是否容易肥胖等等。一个人的一生其实就是其遗传物质执行其编码的过程（这个说法可能不太恰当）。

###### 2.2 计算要素
一套好的表示系统可以更好的表示计算要素，以及表示计算要素之间的逻辑关系，从而可以更好的表示我们的逻辑思维，然后可以加快我们的计算速度。比如：

1+2 = 3

i+ii = iii

很显然，上面两种计算方法中，看不出什么差别，但当计算要素表示的量非常大的时候，就有差别了。
倘若人类进化后得到的是16个手指，而不是10个手指，那么很可能，我们现在比较通用的就是16进制，而非10进制（据说现在流行的十进制源于人类有10根手指头）。相应的，在小学的时候，数学老师会要求小学生背诵16进制乘法表（16进制乘法表也很好编制，最大到“15X15 = 225”，把225化为16进制就是“E1”），而非九九乘法表了。对于同样大小的两个非常大的数字写在纸上，很显然，用16进制表示时更加节约纸张。


待续。。。

