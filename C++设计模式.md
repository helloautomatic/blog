# 原则
### 开放-封闭原则
对源代码的修改是封闭的，对源代码的扩展是开放的

### 单一职责原则

### 依赖倒置原则
解释：intel CPU作为一个独立的个体是非常强内聚的，强到无法至今无法被破解，但是作为通用的CPU，它几乎可以在任何支持intel CPU的电脑主板上插拔更换。
因此，应该针对接口编程，不应该针对实现编程。主板、CPU、RAM都是针对接口设计的，这样就屏蔽了生产商的内部实现。传统做法是高层模块依赖于底层模块，但是
上层类不应该依赖底层类，二者都应该依赖于接口。

### 里氏代换原则
里氏代换原则（Liskov Substitution Principle, LSP）
里氏代换原则是指，子类型必须能够替换掉它们的父类型。也就是说，软件中的对象应该使用基类（或接口）来定义，并且当子类（或实现类）能够替换掉基类（或接口）时，软件的功能不会受到影响。

里氏代换原则的实现要求：
1.子类必须完全实现父类的方法：如果父类是一个接口，则子类必须实现该接口中定义的所有方法；如果父类是一个抽象类，则子类必须实现该抽象类中定义的所有抽象方法。
2.子类可以有自己的个性：子类可以添加新的方法或属性，但不能改变父类原有的方法的行为。
3.子类返回的对象类型必须与父类返回的对象类型相同或更小：这意味着子类的方法返回类型应该是父类方法返回类型的子类或相同类型。

### 迪米特法则
迪米特法则，也称为最少知识原则（Least Knowledge Principle），是面向对象设计中的一条原则，强调对象之间的松耦合和低依赖性。比如，班级类不应该拥有学生类或者教师类的对象，因为这样会导致班级类依赖于教师类和学生类的细节。一旦学生类和教师类发生了变化，就违反了开放封闭原则。

# 模式
### 简单工厂模式
主要解决的是创建对象的问题。

### 策略模式
主要解决的是算法频繁变动的问题

### 装饰模式
至少要有四个类，被装饰对象的抽象类，被装饰对象的具体类，抽象装饰器类，具体装饰器类

### 代理模式
代理模式需要三个类，分别是：追求者，被追求者，代理者或者说是：RealSubject，Proxy，Subject。subject是实体和代理的共同接口。代理类中有
实体类的对象。这样就可以间接的控制实体类的行为。
代理模式的主要作用是：为其他对象提供一个代理以控制对这个对象的访问，降低网络访问或大数据量访问的开销，实现访问权限控制等。
应用：远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。

### 工厂方法模式
会有多个工厂

### 外观模式（又叫门面模式）



