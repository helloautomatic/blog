## `int arr[100];`放在Flash中还是Ram中?

我们知道，stm32中有Flash和RAM，其中Flash用于存储代码和静态数据，这些代码和静态数据都是只读的，不能被修改。
所以`int arr[100];`是放在了Flash中还是Ram中？答案是显然的，它被放在了Ram中。其实，这里的放在了Ram中并不确切，
确切的说法是，在程序开始运行时，运行到`int arr[100];`时，将会在ram中开辟一段空间用于arr。如果`const int arr[100];`这样的
话，那么程序会被放在Flash中。至于放在哪里，需要根据自己的需要决定。

`int arr[100];`这句代码什么时候被执行呢？
在程序正式运行前，会有一个前置的工作，这段代码就是在前置工作中完成的。

## 堆和栈

在个人PC上，当运行一个程序的时候，操作系统会自动给这个程序分配一个栈空间。但是在FreeRTOS中，任务栈的大小是由我们自己指定的。
也就是说，任务运行时的栈空间时由操作系统决定的。只是FreeRTOS比较简单，所以，我们自己给FreeRTOS中的任务指定栈大小。

栈和堆在物理上都是位于RAM，不过，栈通常较小，且大小在编译时就已经确定了。所以，如果我们在程序的全局区写下代码`int arr[N];`，
如果N过大，会导致栈空间不够使用，从而导致程序崩溃。如果是`const int arr[100];`，如果Flash空间不够用的话，编译无法通过。或者
烧录程序的时候出问题。需要注意的是，这里的`const int arr[100];`中的const是指，不可以通过指针修改该指针指向的内容。

堆和栈在软件层面上是不同的，它们采用不同的内存管理方式。栈通常是自动管理的，但是堆的管理需要程序员手动操作。

在个人PC中，栈的大小通常是在编译阶段就确定的，但也受到操作系统的限制。在 Windows 操作系统中，栈的默认大小是由可执行文件的 PE 头部分的 SizeOfStackReserve 字段指定的。在 Linux 操作系统中，栈的大小通常由 ulimit 命令或者 /etc/security/limits.conf 文件中的设置来决定。

在STM32微控制器中，栈的大小通常由链接脚本（Linker Script）中的设置确定。链接脚本是用于告诉编译器如何组织程序在内存中布局的文件。
在实际的STM32项目中，你需要查看使用的具体芯片型号的链接脚本，以了解如何配置栈大小。这些链接脚本通常是由芯片厂商提供的，并且可以在使用的集成开发环境（IDE）中进行配置。

## 程序的启动过程
首先，将Flash中的代码段和数据段加载到RAM中，然后开辟一段空间（空间大小在编译完成后就已经定了）用作堆栈。

## RAM中的堆空间会不会有空间碎片化的问题？
使用malloc开辟空间，使用free释放空间，由于堆的管理方式并不是栈（先进后出）的方式，所以会导致空间的碎片化。空间碎片化可能会导致
RAM的浪费。但是malloc有自己的内存管理算法，可以尽量的减少空间碎片，提高RAM的利用率。

## C语言中，函数的局部变量没有被初始化的情况下，它的随机值是从哪里来的？
在操作系统中（以linux为例），我们运行一个程序的时候，它会从它的父进程那里复制一坨ELF格式的东西（`.data  .rodata  .bss`）过来，**也从父进程那里复制堆栈这些东西**，为我们即将运行的程序开辟虚拟空间。然后，从磁盘（或者说FLASH中）中读取我们已经编译好的可执行程序（Linux是ELF格式）到虚拟空间的对应位置（RAM中的一块内存），覆盖原来的（`.data  .rodata  .bss`），然后**重置堆的指针和栈的指针**。注意，这里是重置指针，而非重置堆栈数据，所以，当我们调用以下代码的时候

```
#include <stdio.h>
int func(void)
{
  int a;
  printf("a = %d",a);
}
```

会打印一串随机的数字。为什么说是随机的呢？这里举个例子。
一个byte的double类型的表示方式如下图所示：

![image](https://github.com/helloautomatic/blog/assets/88640443/09b1e012-1a36-41ac-93f2-1e13203aaff5)

假如有如下代码，父进程堆栈空间中的内容，假设func中的局部变量是从栈底开始的。
```
int func(void)
{
  double a;
}
```

将该空间复制到子进程中的时候，只是重置了堆栈指针，并没有对堆栈内容进行清除，那么`double a;`依然存在于子进程的堆栈中。假如子进程运行时首先运行如下代码（如下代码首先入栈）：
```
int func(void)
{
  int a;
}
```
double类型占据8byte，而int占据4byte，因此，未初始化的`int a`中的内容就是`double a`中前四个byte中的内容。因此，`int a`中的内容是一串没有意义的数字，为什么呢？因为，double的前四个byte（32bit）包括了浮点数的符号位（1bit）、指数部分（11bit）、尾数部分的一部分（20bit），总共32个bit，这32个bit被解析为整数就是一串没有意义的数字。因为，int和double的编码方式不一样。

同样的道理，不同的数据类型，它们的编码格式都不一样。char类型和float不一样。

以此类推，我们得出一个结论就是，在C语言中，未被初始化的局部变量的值来自之前进程的栈中的内容，而且内容是随机的。之所以是随机的，是因为数据的编码格式和长短都不一样。









