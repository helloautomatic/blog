## `int arr[100];`放在Flash中还是Ram中?

我们知道，stm32中有Flash和RAM，其中Flash用于存储代码和静态数据，这些代码和静态数据都是只读的，不能被修改。
所以`int arr[100];`是放在了Flash中还是Ram中？答案是显然的，它被放在了Ram中。其实，这里的放在了Ram中并不确切，
确切的说法是，在程序开始运行时，运行到`int arr[100];`时，将会在ram中开辟一段空间用于arr。如果`const int arr[100];`这样的
话，那么程序会被放在Flash中。至于放在哪里，需要根据自己的需要决定。

`int arr[100];`这句代码什么时候被执行呢？
在程序正式运行前，会有一个前置的工作，这段代码就是在前置工作中完成的。

## 堆和栈

在个人PC上，当运行一个程序的时候，操作系统会自动给这个程序分配一个栈空间。但是在FreeRTOS中，任务栈的大小是由我们自己指定的。
也就是说，任务运行时的栈空间时由操作系统决定的。只是FreeRTOS比较简单，所以，我们自己给FreeRTOS中的任务指定栈大小。

栈和堆在物理上都是位于RAM，不过，栈通常较小，且大小在编译时就已经确定了。所以，如果我们在程序的全局区写下代码`int arr[N];`，
如果N过大，会导致栈空间不够使用，从而导致程序崩溃。如果是`const int arr[100];`，如果Flash空间不够用的话，编译无法通过。或者
烧录程序的时候出问题。需要注意的是，这里的`const int arr[100];`中的const是指，不可以通过指针修改该指针指向的内容。

堆和栈在软件层面上是不同的，它们采用不同的内存管理方式。栈通常是自动管理的，但是堆的管理需要程序员手动操作。

在个人PC中，栈的大小通常是在编译阶段就确定的，但也受到操作系统的限制。在 Windows 操作系统中，栈的默认大小是由可执行文件的 PE 头部分的 SizeOfStackReserve 字段指定的。在 Linux 操作系统中，栈的大小通常由 ulimit 命令或者 /etc/security/limits.conf 文件中的设置来决定。

在STM32微控制器中，栈的大小通常由链接脚本（Linker Script）中的设置确定。链接脚本是用于告诉编译器如何组织程序在内存中布局的文件。
在实际的STM32项目中，你需要查看使用的具体芯片型号的链接脚本，以了解如何配置栈大小。这些链接脚本通常是由芯片厂商提供的，并且可以在使用的集成开发环境（IDE）中进行配置。

## 程序的启动过程
首先，将Flash中的代码段和数据段加载到RAM中，然后开辟一段空间（空间大小在编译完成后就已经定了）用作堆栈。

## RAM中的堆空间会不会有空间碎片化的问题？
使用malloc开辟空间，使用free释放空间，由于堆的管理方式并不是栈（先进后出）的方式，所以会导致空间的碎片化。空间碎片化可能会导致
RAM的浪费。但是malloc有自己的内存管理算法，可以尽量的减少空间碎片，提高RAM的利用率。

## C语言中，函数的局部变量没有被初始化的情况下，它的随机值是从哪里来的？
在操作系统中（以linux为例），我们运行一个程序的时候，它会从它的父进程那里复制一坨ELF格式的东西（`.data  .rodata  .bss`）过来，**也从父进程那里复制堆栈这些东西**，为我们即将运行的程序开辟虚拟空间。然后，从磁盘（或者说FLASH中）中读取我们已经编译好的可执行程序（Linux是ELF格式）到虚拟空间的对应位置（RAM中的一块内存），覆盖原来的（`.data  .rodata  .bss`），然后**重置堆的指针和栈的指针**。注意，这里是重置指针，而非重置堆栈数据，所以，当我们调用以下代码的时候

```
#include <stdio.h>
int func(void)
{
  int a;
  printf("a = %d",a);
}
```

会打印一串随机的数字。为什么说是随机的呢？这里举个例子。
一个byte的double类型的表示方式如下图所示：

![image](https://github.com/helloautomatic/blog/assets/88640443/09b1e012-1a36-41ac-93f2-1e13203aaff5)

假如有如下代码，父进程堆栈空间中的内容，假设func中的局部变量是从栈底开始的。
```
int func(void)
{
  double a;
}
```

将该空间复制到子进程中的时候，只是重置了堆栈指针，并没有对堆栈内容进行清除，那么`double a;`依然存在于子进程的堆栈中。假如子进程运行时首先运行如下代码（如下代码首先入栈）：
```
int func(void)
{
  int a;
}
```
double类型占据8byte，而int占据4byte，因此，未初始化的`int a`中的内容就是`double a`中前四个byte中的内容。因此，`int a`中的内容是一串没有意义的数字，为什么呢？因为，double的前四个byte（32bit）包括了浮点数的符号位（1bit）、指数部分（11bit）、尾数部分的一部分（20bit），总共32个bit，这32个bit被解析为整数就是一串没有意义的数字。因为，int和double的编码方式不一样。

同样的道理，不同的数据类型，它们的编码格式都不一样。char类型和float不一样。

以此类推，我们得出一个结论就是，在C语言中，未被初始化的局部变量的值来自之前进程的栈中的内容，而且内容是随机的。之所以是随机的，是因为数据的编码格式和长短都不一样。

## 裸机和基于OS虚拟内存的运行时的程序布局几乎差不多，二者的共同之处就是，最基本的组成都是 = 代码段 + 静态数据段 + 堆 + 栈

# 为什么stm32中，有那么多类型的电源？比如说，数字电路电源（VDD/VSS）、模拟电源（VDDA/VSSA）？

**在STM32微控制器中，将内部数字电路和模拟电路部分的供电引脚分开的设计是为了提高模拟电路的性能和减少数字电路对模拟电路的干扰。这样的设计主要有以下几个原因：**

#### 减少数字噪声对模拟电路的影响： 数字电路和模拟电路使用不同的供电引脚，可以减少数字电路产生的噪声对模拟电路的影响。数字电路通常会引入快速的信号变化，而这些变化可能通过共享的供电引脚传播到模拟电路中，导致模拟电路的性能下降。

#### 降低数字电路与模拟电路之间的耦合： 数字电路和模拟电路之间存在耦合，即数字信号的高频噪声可能通过供电引脚传播到模拟电路中。通过分开供电引脚，可以降低这种耦合效应，提高模拟电路的精确度和稳定性。

#### 防止数字电路引起的电源波动： 数字电路的工作可能引起瞬时的电源波动，这种波动可能对模拟电路的性能产生负面影响。通过使用独立的供电引脚，可以减少数字电路对模拟电路供电的影响，确保模拟电路的稳定工作。

#### 满足不同应用的需求： 有些应用可能对模拟信号的准确性和稳定性要求很高，因此采用分离的供电引脚可以更好地满足这些需求。同时，对于一些数字信号处理较为简单的应用，也可以选择不使用模拟电路部分，从而减少芯片的功耗和成本。

#### 总体而言，分离数字电路和模拟电路的供电引脚是为了确保数字和模拟部分能够更好地协同工作，提高系统性能和稳定性。这种设计考虑了数字和模拟电路之间的相互影响，以满足不同应用场景的需求。

ADC/DAC中，VREF+/VREF-也是独立的电源

VBAT也是独立的电源

## 函数调用开销和函数占据的内存开销该如何权衡？
宏函数在使用的时候，不做类型检查，也就说，无法检测函数的参数的有效性。
函数的参数类型检查在程序的运行过程中显得非常重要。但是，我们使用宏函数的目的是为了减少程序调用的开销，
如果，在宏函数中也写入了参数检查的东西，那么程序的调用开销就变大了，那么宏函数就失去了意义。
因此，发明了内联函数。同时具有函数的参数检查的性质，又有宏函数减少调用开销的能力。

内联函数，在C11中已经存在了，可以直接使用。但是有时候编译器并不会把我们用关键字`inline`修饰的函数编译为内联函数，编译器可能会自作主张

## {}代码块中的开销和函数调用过程中的开销是一样嘛？
为什么会提出这个问题呢？看下面的代码：

```
#define SWAP(a,b)\
{\
int temp = 0;\
temp = *&(a);\
*&(a) = *&(b);\
*&(b) = temp;\
}

void swap(int *a,int *b)
{
  int temp = 0;
  temp = *a;
  *a = *b;
  *b = temp;
}
```
在上面的代码中，使用函数交换两个变量的值，总共有两种情况，
一种是使用宏函数（它不是函数），在预处理阶段，它会变成一段代码。
另外一种是函数。
这两个情况呢，宏函数虽然经过预处理后变成下面的样子
```
{
int temp = 0;
temp = *&(a);
*&(a) = *&(b);
*&(b) = temp;
}
```
也就是说，会有入栈和出栈的操作，不过这里的入栈和出栈仅仅是栈指针的变化，不会造成太多开销。
但是，函数调用的开销就不一样了，它不仅会有栈指针的变化，还会有下面的三种开销：

保存上下文： 在函数调用时，当前函数的上下文需要被保存，以便在函数返回后能够正确地恢复。这包括局部变量、寄存器值、返回地址等。

压栈与弹栈： 参数传递、局部变量的分配通常涉及栈的操作，函数调用时将参数压栈，局部变量分配在栈上，函数返回时需要弹出栈上的这些数据。

跳转： 函数调用需要进行跳转到被调用函数的地址，并在函数返回时跳回到调用点。












