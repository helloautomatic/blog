## `int arr[100];`放在Flash中还是Ram中?

我们知道，stm32中有Flash和RAM，其中Flash用于存储代码和静态数据，这些代码和静态数据都是只读的，不能被修改。
所以`int arr[100];`是放在了Flash中还是Ram中？答案是显然的，它被放在了Ram中。其实，这里的放在了Ram中并不确切，
确切的说法是，在程序开始运行时，运行到`int arr[100];`时，将会在ram中开辟一段空间用于arr。如果`const int arr[100];`这样的
话，那么程序会被放在Flash中。至于放在哪里，需要根据自己的需要决定。

`int arr[100];`这句代码什么时候被执行呢？
在程序正式运行前，会有一个前置的工作，这段代码就是在前置工作中完成的。

## 堆和栈

在个人PC上，当运行一个程序的时候，操作系统会自动给这个程序分配一个栈空间。但是在FreeRTOS中，任务栈的大小是由我们自己指定的。
也就是说，任务运行时的栈空间时由操作系统决定的。只是FreeRTOS比较简单，所以，我们自己给FreeRTOS中的任务指定栈大小。

栈和堆在物理上都是位于RAM，不过，栈通常较小，且大小在编译时就已经确定了。所以，如果我们在程序的全局区写下代码`int arr[N];`，
如果N过大，会导致栈空间不够使用，从而导致程序崩溃。如果是`const int arr[100];`，如果Flash空间不够用的话，编译无法通过。或者
烧录程序的时候出问题。需要注意的是，这里的`const int arr[100];`中的const是指，不可以通过指针修改该指针指向的内容。

堆和栈在软件层面上是不同的，它们采用不同的内存管理方式。栈通常是自动管理的，但是堆的管理需要程序员手动操作。

在个人PC中，栈的大小通常是在编译阶段就确定的，但也受到操作系统的限制。在 Windows 操作系统中，栈的默认大小是由可执行文件的 PE 头部分的 SizeOfStackReserve 字段指定的。在 Linux 操作系统中，栈的大小通常由 ulimit 命令或者 /etc/security/limits.conf 文件中的设置来决定。

在STM32微控制器中，栈的大小通常由链接脚本（Linker Script）中的设置确定。链接脚本是用于告诉编译器如何组织程序在内存中布局的文件。
在实际的STM32项目中，你需要查看使用的具体芯片型号的链接脚本，以了解如何配置栈大小。这些链接脚本通常是由芯片厂商提供的，并且可以在使用的集成开发环境（IDE）中进行配置。

## 程序的启动过程
首先，将Flash中的代码段和数据段加载到RAM中，然后开辟一段空间（空间大小在编译完成后就已经定了）用作堆栈。

## RAM中的堆空间会不会有空间碎片化的问题？
使用malloc开辟空间，使用free释放空间，由于堆的管理方式并不是栈（先进后出）的方式，所以会导致空间的碎片化。空间碎片化可能会导致
RAM的浪费。但是malloc有自己的内存管理算法，可以尽量的减少空间碎片，提高RAM的利用率。





